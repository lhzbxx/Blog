---
title: 「情书」的制作（第一版）
tags:
  - LoveLetter
date: 2016-07-27 22:27:44
updated: 2016-07-27 22:27:44
categories: 开发手札
---

「情书」是一个非常有趣的桌面游戏。

之前花了大概15块软妹币买的盗版，如果没记错的话，应该是和小白世纪、瘟疫危机和诈赌巫师一起买来的。但是每个游戏都尝试了一遍后，发现最耐玩的竟然是这个只有16张纸牌组成的游戏！

规则设计的十分巧妙，简单而富有乐趣，让人充满了“策略感”。我认为从桌游设计上来说，这个游戏是非常厉害的，BGG上的排名其实也说明了一切。这套牌也有一系列衍生的艺术作品，不过这里就不延伸了。

<!-- more -->

## 前言

首先提供一个链接吧。

英文规则书下载：{% asset_link Love_Letter_Rules_Final.pdf [Love Letter Rules] %}

神马？你说中文的规则？这个就自己Google了好伐，网上还是蛮多资源的，甚至还有DIY的素材。

到写这篇博客的时候，我实际上已经完成了第一版的制作。

下面简单说一些思路和感想。

## 思路

其实在制作第一版之前，有一个类似「Tracer Bullet」的试验品，使用「Flask」作为REST API来实现前后端的通信。

但是实在是太麻烦了，虽说写API倒还好，但涉及到前端的时候，感觉完全无法动手。一来REST作为无状态协议，本身维护客户端的状态就很吃力，二来前端每次都要主动拉取服务端处理的结果，非常麻烦，更何况桌面游戏一般都是两个人以上参与的。

所以现在主要以「Socket.io」作为主要组件进行实现，有点类似于有限状态机的意味，状态的转移通过客户端与服务器建立的套接字实现。

服务端主要作为计算流程和对结果的处理通知，客户端主要作为信息传递和展示的平台，同时辅以一些简单的限制来减轻服务器（代码上）的压力，一个实例是，实现女伯爵的卡片限制的时候，服务器其实蛮难处理这件事的，但客户端却非常容易实现。

在服务端，主要用Redis来存储临时的状态，比如牌库、玩家状态和手牌信息。

因为是用Node来进行实现，服务端里基本上都是成片成片的函数，利用回调处理结果。

## 不足和隐患

我觉得Socket.io+Node这个技术栈本身是没什么问题的，主要问题在于写法上。

就是传说中的Callback Hell。

其实一开始这个问题并不明显。

直到我手贱加入了三个功能：

1. 所有玩家准备好后，等待10秒开始游戏，如果有玩家退出，则重新计时。

2. 如果牌局上仅有一名玩家没有准备，则等待10秒后强制玩家准备。

3. 观战系统。

天了噜，从此我的代码中就是各种callback和大括号了。

其次还有一个小小的隐患是，在CS通信的时候，没有设定消息序列，没有对乱序进行处理的机制——虽然我也没有仔细考虑其中的问题，不过毕竟是一个小东西，所以暂时不考虑了。

## 感想

说一下接下来改良的思路吧。

1. 首先实现模块化，一大坨一大坨的函数虽然写的时候还算顺畅，但写完之后真的有点「在人群中淹没，不知所措」的感觉。

2. 改进回调，使用Promise。

OK，就这样啦！

---